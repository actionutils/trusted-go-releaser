name: Trusted Go Release Workflow

# This workflow creates a secure release for GitHub repositories
# It's designed as a reusable workflow that can be called from other workflows
# It enforces releases only through labeled PRs (bump:patch, bump:minor, bump:major)
on:
  workflow_call:
    inputs:
      ref:
        description: 'The ref to checkout (commit SHA, tag, or branch)'
        required: false
        default: ${{ github.sha }}
        type: string
      draft:
        description: 'Whether to keep the release as a draft'
        required: false
        type: boolean
        default: false
      setup-zig:
        description: 'Whether to setup Zig for cross-compilation'
        required: false
        type: boolean
        default: false
      zig-version:
        description: 'Zig version to use (e.g., 0.13.0, master). Defaults to latest stable'
        required: false
        type: string
        default: ''
      setup-go:
        description: 'Whether to setup Go. Defaults to true unless Zig is enabled. Set explicitly to override'
        required: false
        type: string
        default: ''
      go-version-file:
        description: 'Path to go.mod or go.work file for Go version'
        required: false
        type: string
        default: 'go.mod'
      install-mingw-dlltool:
        description: 'Whether to install mingw binutils (dlltool) for Windows GNU builds'
        required: false
        type: boolean
        default: false
      environment:
        description: 'Environment for protecting the release flow'
        required: false
        type: string
      release-notes:
        description: 'Custom release notes content (overrides auto-generated notes)'
        required: false
        type: string
    secrets:
      github-token:
        description: 'GitHub token with appropriate permissions'
        required: true
    outputs:
      tag_name:
        description: 'The tag name created or used for this release'
        value: ${{ jobs.version.outputs.tag_name }}
      version:
        description: 'The version number without "v" prefix'
        value: ${{ jobs.version.outputs.version }}
      release_url:
        description: 'URL of the created GitHub release'
        value: ${{ jobs.release.outputs.release_url }}

permissions:
  contents: read

jobs:
  # Check if a release is needed (dry-run)
  release-check:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required for GitHub's generate-release-note API (notes are only displayed in job summary, not written to any file)
    outputs:
      skip: ${{ steps.bumpr-dry-run.outputs.skip }}
      next_version: ${{ steps.bumpr-dry-run.outputs.next_version }}
      current_version: ${{ steps.bumpr-dry-run.outputs.current_version }}
      message: ${{ steps.bumpr-dry-run.outputs.message }}
      temp_branch: ${{ steps.create-temp-branch.outputs.temp_branch }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: ${{ inputs.ref }}

      # Dry run to check if a version bump is needed
      - id: bumpr-dry-run
        uses: haya14busa/action-bumpr@faf6f474bcb6174125cfc569f0b2e24cbf03d496 # v1.11.4
        with:
          dry_run: true

      # Create temporary branch to prevent GitHub workflow permission error
      #
      # PROBLEM:
      # GitHub incorrectly requires 'workflow: write' permission when pushing tags,
      # even though tags don't actually create or update workflows. The error message:
      # "refusing to allow a GitHub App to create or update workflow .github/workflows/xxx.yaml without workflows permission"
      #
      # This error occurs when:
      # 1. This release workflow is running
      # 2. The main branch gets updated with changes to .github/workflows/
      # 3. We try to push a tag pointing to the older commit
      # 4. GitHub rejects it because no branch HEAD has the same workflow files
      #
      # WHY WE CAN'T JUST ADD 'workflow: write':
      # The default GITHUB_TOKEN in GitHub Actions cannot be granted 'workflow: write'
      # permission for security reasons. Using a PAT with this permission is not
      # recommended as it bypasses important security boundaries.
      #
      # WORKAROUND:
      # Create a temporary 'keep-ref-<version>' branch at the release commit.
      # This ensures at least one branch exists with the exact workflow files
      # from the release commit, satisfying GitHub's check.
      #
      # TIMING:
      # We create this branch early (right after determining the version) because
      # the release-approval job may wait for human approval, during which the
      # main branch could be updated.
      #
      # See: https://github.com/orgs/community/discussions/151442
      - name: Create temporary branch for tag push workaround
        id: create-temp-branch
        if: steps.bumpr-dry-run.outputs.skip != 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.github-token || github.token }}
        run: |
          NEXT_VERSION="${{ steps.bumpr-dry-run.outputs.next_version }}"
          COMMIT_SHA="${{ github.sha }}"
          # Include short commit hash to ensure uniqueness across re-runs/concurrent runs
          SHORT_SHA="${COMMIT_SHA:0:7}"
          TEMP_BRANCH="keep-ref-${NEXT_VERSION}-${SHORT_SHA}"

          echo "Creating temporary branch '${TEMP_BRANCH}' as workaround for GitHub workflow permission issue"
          echo "This prevents 'refusing to allow a GitHub App to create or update workflow' errors"
          echo "when the main branch is updated with different workflow files during release."
          echo "Branch includes commit hash for uniqueness in case of re-runs or concurrent workflows."

          # Create the temporary branch using GitHub API
          # This is cleaner than using git commands and doesn't require git config changes
          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${GITHUB_REPOSITORY}/git/refs" \
            -f "ref=refs/heads/${TEMP_BRANCH}" \
            -f "sha=${COMMIT_SHA}"

          echo "‚úÖ Temporary branch '${TEMP_BRANCH}' created successfully at commit ${COMMIT_SHA}"

          # Output the branch name for cleanup job
          echo "temp_branch=${TEMP_BRANCH}" >> "$GITHUB_OUTPUT"

      # Add release information to job summary
      - name: Add release information to job summary
        env:
          GITHUB_TOKEN: ${{ github.token }}
          CUSTOM_RELEASE_NOTES: ${{ inputs.release-notes }}
        run: |
          echo "# Release Check Summary" >> "$GITHUB_STEP_SUMMARY"

          if [[ "${{ steps.bumpr-dry-run.outputs.skip }}" == "true" ]]; then
            {
              echo "## ‚ö†Ô∏è No Release Needed"
              echo "No version bump label was found on the PR. Release will be skipped."
            } >> "$GITHUB_STEP_SUMMARY"
          else
            {
              echo "## ‚úÖ Release Needed"
              echo "A version bump label was found. The following release will be created:"
              echo ""
            } >> "$GITHUB_STEP_SUMMARY"

            # Use action-bumpr outputs with better formatting
            if [[ "${{ steps.bumpr-dry-run.outputs.next_version }}" != "" ]]; then
              CURRENT_VERSION="${{ steps.bumpr-dry-run.outputs.current_version }}"
              NEXT_VERSION="${{ steps.bumpr-dry-run.outputs.next_version }}"
              REPO_URL="https://github.com/${{ github.repository }}"
              COMPARE_URL="$REPO_URL/compare/$CURRENT_VERSION...${{ github.sha }}"

              # Create a more visually appealing format with emojis
              {
                echo "### Release Details"
                echo ""
                echo "üè∑Ô∏è **New Version:** \`$NEXT_VERSION\`"
                echo ""
                echo "üì¶ **Current Version:** \`$CURRENT_VERSION\`"
                echo ""
              } >> "$GITHUB_STEP_SUMMARY"

              # Add tag message if available
              if [[ "${{ steps.bumpr-dry-run.outputs.message }}" != "" ]]; then
                {
                  echo "üìù **Tag Message:** ${{ steps.bumpr-dry-run.outputs.message }}"
                  echo ""
                } >> "$GITHUB_STEP_SUMMARY"
              fi

              # Add GitHub compare link
              {
                echo "üìä **Changes:** [View changes since $CURRENT_VERSION]($COMPARE_URL)"
                echo ""
              } >> "$GITHUB_STEP_SUMMARY"

              # Generate and add release notes
              {
                echo "### üìù Release Notes Preview"
                echo ""
              } >> "$GITHUB_STEP_SUMMARY"

              # Check if custom release notes are provided
              if [[ -n "${CUSTOM_RELEASE_NOTES}" ]]; then
                # Use custom release notes
                {
                  echo "**Note:** Using custom release notes provided as input"
                  echo ""
                  echo "${CUSTOM_RELEASE_NOTES}"
                  echo ""
                } >> "$GITHUB_STEP_SUMMARY"
              else
                # Generate release notes using GitHub API
                REPO="${{ github.repository }}"

                # Call the API with the parameters (CURRENT_VERSION will be empty string if not set)
                RELEASE_NOTES=$(gh api \
                  --method POST \
                  -H "Accept: application/vnd.github+json" \
                  "/repos/${REPO}/releases/generate-notes" \
                  -f target_commitish="${{ github.sha }}" \
                  -f tag_name="$NEXT_VERSION" \
                  -f previous_tag_name="$CURRENT_VERSION" \
                  --jq '.body')

                # Add the generated release notes to the summary
                {
                  echo "$RELEASE_NOTES"
                  echo ""
                } >> "$GITHUB_STEP_SUMMARY"
              fi
            fi
          fi

  # Environment protection job
  # This job intentionally deploys to the environment to satisfy environment
  # protection rules and avoid "Missing successful active release deployment".
  # It also serves as the single approval gate for the release flow.
  release-approval:
    needs: [release-check]
    if: needs.release-check.outputs.skip != 'true'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    concurrency:
      group: "release-approval"
      cancel-in-progress: true
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Approve release
        run: |
          echo "Release approved in the '${{ inputs.environment }}' environment"
          echo "This job exists to satisfy environment deployment requirements."

  # Version management and tag creation job
  version:
    needs: [release-approval]
    runs-on: ubuntu-latest
    permissions:
      id-token: write # Enable OIDC
      contents: write # Tag updates
      pull-requests: write # Post comment
    outputs:
      tag_name: ${{ steps.tag.outputs.value }}
      version: ${{ steps.extract-version.outputs.version }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - uses: actions/checkout@v5
        with:
          ref: ${{ inputs.ref }}

      # Set up signed tag configuration
      - uses: chainguard-dev/actions/setup-gitsign@v1.5.1

      # Bump version based on PR labels (bump:major,bump:minor,bump:patch)
      - id: bumpr
        uses: haya14busa/action-bumpr@v1.11.4

      # Get tag name from bumpr output only
      - id: tag
        run: |
          if [[ "${{ steps.bumpr.outputs.skip }}" == "true" ]]; then
            echo "value=" >> "$GITHUB_OUTPUT"
            echo "No version bump label found, skipping release."
          else
            TAG="${{ steps.bumpr.outputs.next_version }}"
            echo "value=${TAG}" >> "$GITHUB_OUTPUT"
            echo "Next version: ${TAG}"
          fi

      # Extract version number without "v" prefix (v1.2.3 ‚Üí 1.2.3)
      - id: extract-version
        if: steps.tag.outputs.value != ''
        run: |
          TAG="${{ steps.tag.outputs.value }}"
          VERSION="${TAG#refs/tags/v}"
          VERSION="${VERSION#v}"
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "Extracted version: ${VERSION}"

  goreleaser:
    needs: [release-approval, version]
    if: needs.version.outputs.tag_name != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write # needed to write releases
      id-token: write # needed for keyless signing
      attestations: write # needed for provenance
    outputs:
      artifacts: ${{ steps.goreleaser.outputs.artifacts }}
      checksum_file: ${{ steps.checksumtxt.outputs.checksum_file }}
      hashes: ${{ steps.binstaller-hashes.outputs.combined_hashes || steps.checksumtxt.outputs.hashes }}
      config_exists: ${{ steps.check-config.outputs.config_exists }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - uses: actions/checkout@v5
        with:
          ref: ${{ inputs.ref }}
          fetch-depth: 0 # this is important, otherwise it won't checkout the full tree (i.e. no previous tags)

      # Determine whether to setup Go
      # Logic:
      # - If setup-go is explicitly set (true/false), use that value
      # - Otherwise, setup Go unless Zig is enabled
      - name: Determine Go setup
        id: determine-go-setup
        run: |
          if [[ "${{ inputs.setup-go }}" == "true" ]]; then
            echo "should_setup=true" >> "$GITHUB_OUTPUT"
          elif [[ "${{ inputs.setup-go }}" == "false" ]]; then
            echo "should_setup=false" >> "$GITHUB_OUTPUT"
          elif [[ "${{ inputs.setup-zig }}" == "true" ]]; then
            echo "should_setup=false" >> "$GITHUB_OUTPUT"
          else
            echo "should_setup=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Setup Go
        if: steps.determine-go-setup.outputs.should_setup == 'true'
        uses: actions/setup-go@v6
        with:
          go-version-file: ${{ inputs.go-version-file }}

      - name: Setup Zig
        if: inputs.setup-zig
        uses: mlugg/setup-zig@8d6198c65fb0feaa111df26e6b467fea8345e46f # v2.0.5
        with:
          version: ${{ inputs.zig-version }}

      # Provide dlltool for windows-gnu without hijacking cc/c++
      - name: Install mingw binutils (dlltool)
        if: inputs.install-mingw-dlltool
        run: sudo apt-get update && sudo apt-get install -y binutils-mingw-w64

      - uses: sigstore/cosign-installer@v3.9.2 # installs cosign
      - uses: anchore/sbom-action/download-syft@v0.20.5 # installs syft

      # Create temporary release notes file if custom notes are provided
      - name: Prepare custom release notes
        if: inputs.release-notes != ''
        id: custom-release-notes
        env:
          CUSTOM_RELEASE_NOTES: ${{ inputs.release-notes }}
        run: |
          NOTES_FILE=$(mktemp)
          echo "$CUSTOM_RELEASE_NOTES" > "$NOTES_FILE"
          echo "file=$NOTES_FILE" >> "$GITHUB_OUTPUT"

      - uses: goreleaser/goreleaser-action@v6 # run goreleaser
        id: goreleaser
        with:
          version: '~> v2'
          args: release --clean --draft${{ steps.custom-release-notes.outputs.file && format(' --release-notes {0}', steps.custom-release-notes.outputs.file) || '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Get checksum file name
        id: checksumtxt
        env:
          ARTIFACTS: ${{ steps.goreleaser.outputs.artifacts }}
        run: |
          checksum_file=$(echo "$ARTIFACTS" | jq -r '.[] | select (.type=="Checksum") | .name')
          echo "checksum file: ${checksum_file}"
          echo "checksum_file=${checksum_file}" >> "$GITHUB_OUTPUT"
          echo "hashes=$(cat "dist/$checksum_file" | base64 -w0)" >> "$GITHUB_OUTPUT"
      - uses: actions/attest-build-provenance@v3
        with:
          subject-checksums: ./dist/${{ steps.checksumtxt.outputs.checksum_file }}
      # Generate attestations for checksum file itself.
      - uses: actions/attest-build-provenance@v3
        with:
          subject-path: ./dist/${{ steps.checksumtxt.outputs.checksum_file }}

      # Binstaller steps
      - name: Check for binstaller config
        id: check-config
        run: |
          if [[ -f .config/binstaller.yml || -f .config/binstaller.yaml ]]; then
            echo "config_exists=true" >> "$GITHUB_OUTPUT"
            echo "Binstaller config found"
          else
            echo "config_exists=false" >> "$GITHUB_OUTPUT"
            echo "No binstaller config found, skipping binstaller steps"
          fi
      - uses: actionutils/trusted-tag-verifier@v0
        if: steps.check-config.outputs.config_exists == 'true'
        with:
          verify: 'binary-install/setup-x@v1'
      - name: Install binstaller
        if: steps.check-config.outputs.config_exists == 'true'
        uses: binary-install/setup-x@v1
        with:
          script_url: https://raw.githubusercontent.com/binary-install/binstaller/main/install.sh
          gh_attestations_verify_flags: --repo binary-install/binstaller --cert-identity-regex=.github/workflows/generate-installer.yml@refs/heads/main
      - name: Embed checksums
        if: steps.check-config.outputs.config_exists == 'true'
        env:
          checksum_file: ${{ steps.checksumtxt.outputs.checksum_file }}
        run: binst embed-checksums --mode=checksum-file --file="./dist/${checksum_file}" --version='${{ needs.version.outputs.tag_name }}'
      - name: Generate installer and runner scripts
        if: steps.check-config.outputs.config_exists == 'true'
        run: |
          binst gen --type=installer --target-version='${{ needs.version.outputs.tag_name }}' --output=./dist/install.sh
          binst gen --type=runner --target-version='${{ needs.version.outputs.tag_name }}' --output=./dist/run.sh
      - name: Sign installer and runner with cosign
        if: steps.check-config.outputs.config_exists == 'true'
        run: |
          cosign sign-blob \
            --yes \
            --output-signature ./dist/install.sh.sig \
            --output-certificate ./dist/install.sh.pem \
            ./dist/install.sh
          cosign sign-blob \
            --yes \
            --output-signature ./dist/run.sh.sig \
            --output-certificate ./dist/run.sh.pem \
            ./dist/run.sh
      - name: Upload installer and runner to release
        if: steps.check-config.outputs.config_exists == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release upload '${{ needs.version.outputs.tag_name }}' \
            ./dist/install.sh \
            ./dist/install.sh.sig \
            ./dist/install.sh.pem \
            ./dist/run.sh \
            ./dist/run.sh.sig \
            ./dist/run.sh.pem
      - name: Calculate binstaller scripts hashes
        if: steps.check-config.outputs.config_exists == 'true'
        id: binstaller-hashes
        run: |
          cd dist
          # Combine goreleaser checksums with installer/runner scripts hashes in one command
          checksum_file="${{ steps.checksumtxt.outputs.checksum_file }}"
          combined_hashes=$(cat "$checksum_file" <(sha256sum install.sh run.sh) | base64 -w0)

          echo "combined_hashes=${combined_hashes}" >> "$GITHUB_OUTPUT"
          echo "Binstaller scripts hashes calculated and combined"
      - name: Attest binstaller scripts
        if: steps.check-config.outputs.config_exists == 'true'
        uses: actions/attest-build-provenance@v3
        with:
          subject-path: |
            ./dist/install.sh
            ./dist/run.sh

  provenance:
    if: needs.version.outputs.tag_name != ''
    needs: [release-approval, version, goreleaser]
    permissions:
      actions: read # To read the workflow path.
      id-token: write # To sign the provenance.
      contents: write # To add assets to a release.
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@v2.1.0
    with:
      base64-subjects: "${{ needs.goreleaser.outputs.hashes }}"
      upload-assets: true # upload to a new release
      upload-tag-name: "${{ needs.version.outputs.tag_name }}"
      draft-release: true # use existing draft release created by goreleaser

  release:
    needs: [release-approval, version, goreleaser, provenance]
    if: needs.version.outputs.tag_name != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required for release creation
    outputs:
      release_url: ${{ steps.update_release.outputs.release_url }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
          ref: ${{ needs.version.outputs.tag_name }}

      - name: Create base verification instructions
        id: create_base_instructions
        run: |
          TEMP_FILE=$(mktemp)
          cat > "$TEMP_FILE" << 'EOF'

          <details>
          <summary>üìã Release Verification Instructions</summary>

          ## Verifying Release Artifacts

          ### Using Cosign

          All release artifacts are signed using [Sigstore](https://sigstore.dev/) and can be verified using [cosign](https://github.com/sigstore/cosign):

          ```bash
          # Download the release assets
          gh release download ${{ needs.version.outputs.tag_name }} --repo ${{ github.repository }}

          # Verify the checksum file signature
          cosign verify-blob \
            --certificate-identity-regexp '^https://github.com/actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml@.*$' \
            --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \
            --cert "${{ needs.goreleaser.outputs.checksum_file }}.pem" \
            --signature "${{ needs.goreleaser.outputs.checksum_file }}.sig" \
            "${{ needs.goreleaser.outputs.checksum_file }}"

          # Verify checksums of all binaries
          sha256sum --ignore-missing -c "${{ needs.goreleaser.outputs.checksum_file }}"
          ```

          ### Using GitHub Attestations

          All artifacts have [GitHub Attestations](https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds) that can be verified:

          ```bash
          # Verify attestations for the checksum file
          gh attestation verify "${{ needs.goreleaser.outputs.checksum_file }}" --repo ${{ github.repository }} --signer-workflow='actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml'
          ```

          EOF
          echo "base_instructions_file=$TEMP_FILE" >> "$GITHUB_OUTPUT"

      - name: Add binstaller instructions
        id: add_binstaller_instructions
        run: |
          BASE_FILE="${{ steps.create_base_instructions.outputs.base_instructions_file }}"
          echo "Binstaller config exists: ${{ needs.goreleaser.outputs.config_exists }}"

          # Close the verification instructions details
          cat >> "$BASE_FILE" << 'CLOSE_VERIFICATION_EOF'

          </details>
          CLOSE_VERIFICATION_EOF

          if [[ "${{ needs.goreleaser.outputs.config_exists }}" == "true" ]]; then
            echo "Adding binstaller instructions..."
            cat >> "$BASE_FILE" << 'BINSTALLER_EOF'

          <details>
          <summary>üì¶ Installation Scripts</summary>

          This release includes installation scripts generated by [binstaller](https://github.com/binary-install/binstaller):

          - `install.sh` - Downloads and installs the binary
          - `run.sh` - Downloads and runs the binary directly

          ## Verifying Installation Scripts

          Before using the installation scripts, you can verify their authenticity using cosign (signatures) or GitHub Attestations.

          ```bash
          # Download the scripts and their signatures
          gh release download ${{ needs.version.outputs.tag_name }} --pattern "*.sh*" --repo ${{ github.repository }}

          # Verify with cosign (recommended)
          cosign verify-blob \
            --certificate-identity-regexp '^https://github.com/actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml@.*$' \
            --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \
            --cert install.sh.pem \
            --signature install.sh.sig \
            install.sh

          cosign verify-blob \
            --certificate-identity-regexp '^https://github.com/actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml@.*$' \
            --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \
            --cert run.sh.pem \
            --signature run.sh.sig \
            run.sh

          # Or verify with GitHub Attestations
          # Verify the install script
          gh attestation verify install.sh --repo ${{ github.repository }} --signer-workflow='actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml'

          # Verify the run script
          gh attestation verify run.sh --repo ${{ github.repository }} --signer-workflow='actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml'
          ```

          ## Using Installation Scripts

          ```bash
          # Install the binary
          curl -sSfL https://github.com/${{ github.repository }}/releases/download/${{ needs.version.outputs.tag_name }}/install.sh | sh

          # Or run directly without installation
          curl -sSfL https://github.com/${{ github.repository }}/releases/download/${{ needs.version.outputs.tag_name }}/run.sh | sh
          ```

          ## One-liner Installation with Verification

          ### Using Cosign (recommended)

          ```bash
          # Set the desired version and script type
          VERSION="${{ needs.version.outputs.tag_name }}"
          SCRIPT="install.sh"  # or "run.sh"
          DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/${VERSION}"

          # Download and verify with cosign, then execute
          curl -sL "${DOWNLOAD_URL}/${SCRIPT}" | \
              (tmpfile=$(mktemp); cat > "$tmpfile"; \
               cosign verify-blob \
                 --certificate-identity-regexp '^https://github.com/actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml@.*$' \
                 --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \
                 --certificate "${DOWNLOAD_URL}/${SCRIPT}.pem" \
                 --signature "${DOWNLOAD_URL}/${SCRIPT}.sig" \
                 "$tmpfile" && \
               sh "$tmpfile"; rm -f "$tmpfile")
          ```

          ### Using GitHub Attestations

          ```bash
          # Set the desired version
          VERSION="${{ needs.version.outputs.tag_name }}"

          # Install with attestation verification
          curl -sL "https://github.com/${{ github.repository }}/releases/download/${VERSION}/install.sh" | \
              (tmpfile=$(mktemp); cat > "$tmpfile"; \
               gh attestation verify --repo=${{ github.repository }} --signer-workflow='actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml' "$tmpfile" && \
               sh "$tmpfile"; rm -f "$tmpfile")
          ```

          </details>
          BINSTALLER_EOF
          else
            echo "No binstaller config found, skipping binstaller instructions"
          fi

          echo "instructions_file=$BASE_FILE" >> "$GITHUB_OUTPUT"


      - name: Update GitHub Release
        id: update_release
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
          CUSTOM_RELEASE_NOTES: ${{ inputs.release-notes }}
        run: |
          TAG_NAME="${{ needs.version.outputs.tag_name }}"

          # Determine release body content
          if [[ -n "${CUSTOM_RELEASE_NOTES}" ]]; then
            # Use custom release notes if provided
            RELEASE_BODY="${CUSTOM_RELEASE_NOTES}"
          else
            # Get current release body (auto-generated by goreleaser)
            RELEASE_BODY=$(gh release view "$TAG_NAME" --json body --jq '.body')
          fi

          # Get final verification instructions
          VERIFICATION_INSTRUCTIONS=$(cat "${{ steps.add_binstaller_instructions.outputs.instructions_file }}")

          # Combine release body with verification instructions
          NEW_BODY="${RELEASE_BODY}${VERIFICATION_INSTRUCTIONS}"

          # Update release with combined body
          RELEASE_URL=$(gh release edit "$TAG_NAME" \
            --title "Release $TAG_NAME" \
            --notes "$NEW_BODY" \
            --draft=${{ inputs.draft }})

          echo "release_url=$RELEASE_URL" >> "$GITHUB_OUTPUT"
          echo "Release URL: $RELEASE_URL"

  # https://goreleaser.com/install/#verifying-the-artifacts
  verification-with-cosign:
    needs: [release-approval, version, release, goreleaser]
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.9.2

      - name: Download assets
        env:
          GH_TOKEN: ${{ github.token }}
          TAG_NAME: ${{ needs.version.outputs.tag_name }}
        run: |
          gh -R "${GITHUB_REPOSITORY}" release download "${TAG_NAME}"

      - name: Verify checksum signature
        env:
          checksum_file: ${{ needs.goreleaser.outputs.checksum_file }}
        run: |
          cosign verify-blob \
            --certificate-identity-regexp '^https://github.com/actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml@.*$' \
            --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \
            --cert "${checksum_file}.pem" \
            --signature "${checksum_file}.sig" \
            "${checksum_file}"

      - name: Verify checksum
        env:
          checksum_file: ${{ needs.goreleaser.outputs.checksum_file }}
        run: |
          sha256sum --ignore-missing -c "${checksum_file}"
      - name: Verify installer/runner signatures
        run: |
          if [[ -f install.sh && -f install.sh.sig && -f install.sh.pem ]]; then
            cosign verify-blob \
              --certificate-identity-regexp '^https://github.com/actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml@.*$' \
              --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \
              --cert install.sh.pem \
              --signature install.sh.sig \
              install.sh
          fi
          if [[ -f run.sh && -f run.sh.sig && -f run.sh.pem ]]; then
            cosign verify-blob \
              --certificate-identity-regexp '^https://github.com/actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml@.*$' \
              --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \
              --cert run.sh.pem \
              --signature run.sh.sig \
              run.sh
          fi

  # Clean up temporary branch that was created as a workaround
  #
  # This job deletes the 'keep-ref-<version>' branch that was created to work around
  # GitHub's workflow permission issue. The branch is no longer needed after the release
  # and verification processes are complete.
  #
  # The job runs with 'if: always()' to ensure cleanup happens even if other jobs fail,
  # preventing accumulation of temporary branches in the repository.
  cleanup-temp-branch:
    needs: [release-check, verification-with-cosign]
    # Always run cleanup, even if previous jobs failed, but only if we started a release
    if: always() && needs.release-check.outputs.skip != 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required to delete branch
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      # Clean up temporary branch created during tag push
      # This branch was created as a workaround for GitHub's workflow permission issue
      # See: https://github.com/orgs/community/discussions/151442
      - name: Delete temporary branch
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
        run: |
          # Get the exact branch name that was created
          TEMP_BRANCH="${{ needs.release-check.outputs.temp_branch }}"

          if [[ -z "${TEMP_BRANCH}" ]]; then
            echo "No temporary branch to clean up (may have been skipped)"
            exit 0
          fi

          echo "Cleaning up temporary branch '${TEMP_BRANCH}' used for workflow permission workaround"

          # Delete the temporary branch (ignore errors if it doesn't exist)
          if gh api "repos/${GITHUB_REPOSITORY}/git/refs/heads/${TEMP_BRANCH}" --silent 2>/dev/null; then
            gh api --method DELETE "repos/${GITHUB_REPOSITORY}/git/refs/heads/${TEMP_BRANCH}" || true
            echo "‚úÖ Temporary branch '${TEMP_BRANCH}' deleted successfully"
          else
            echo "‚ÑπÔ∏è Temporary branch '${TEMP_BRANCH}' not found (may have been already deleted)"
          fi

          echo "Cleanup completed"
