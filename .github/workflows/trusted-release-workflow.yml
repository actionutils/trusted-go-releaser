name: Trusted Go Release Workflow

# This workflow creates a secure release for GitHub repositories
# It's designed as a reusable workflow that can be called from other workflows
# It enforces releases only through labeled PRs (bump:patch, bump:minor, bump:major)
on:
  workflow_call:
    inputs:
      ref:
        description: 'The ref to checkout (commit SHA, tag, or branch)'
        required: false
        default: ${{ github.sha }}
        type: string
      draft:
        description: 'Whether to keep the release as a draft'
        required: false
        type: boolean
        default: false
      setup-zig:
        description: 'Whether to setup Zig for cross-compilation'
        required: false
        type: boolean
        default: false
      zig-version:
        description: 'Zig version to use (e.g., 0.13.0, master). Defaults to latest stable'
        required: false
        type: string
        default: ''
      setup-go:
        description: 'Whether to setup Go. Defaults to true unless Zig is enabled. Set explicitly to override'
        required: false
        type: string
        default: ''
      go-version-file:
        description: 'Path to go.mod or go.work file for Go version'
        required: false
        type: string
        default: 'go.mod'
      install-mingw-dlltool:
        description: 'Whether to install mingw binutils (dlltool) for Windows GNU builds'
        required: false
        type: boolean
        default: false
      environment:
        description: 'Environment for protecting the release flow'
        required: false
        type: string
      release-notes:
        description: 'Custom release notes content (overrides auto-generated notes)'
        required: false
        type: string
    secrets:
      github-token:
        description: 'GitHub token with appropriate permissions'
        required: true
    outputs:
      tag_name:
        description: 'The tag name created or used for this release'
        value: ${{ jobs.version.outputs.tag_name }}
      version:
        description: 'The version number without "v" prefix'
        value: ${{ jobs.version.outputs.version }}
      release_url:
        description: 'URL of the created GitHub release'
        value: ${{ jobs.release.outputs.release_url }}

permissions:
  contents: read

jobs:
  # Check if a release is needed (dry-run)
  release-check:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required for GitHub's generate-release-note API (notes are only displayed in job summary, not written to any file)
    outputs:
      skip: ${{ steps.bumpr-dry-run.outputs.skip }}
      next_version: ${{ steps.bumpr-dry-run.outputs.next_version }}
      current_version: ${{ steps.bumpr-dry-run.outputs.current_version }}
      message: ${{ steps.bumpr-dry-run.outputs.message }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: ${{ inputs.ref }}

      # Dry run to check if a version bump is needed
      - id: bumpr-dry-run
        uses: haya14busa/action-bumpr@faf6f474bcb6174125cfc569f0b2e24cbf03d496 # v1.11.4
        with:
          dry_run: true

      # Add release information to job summary
      - name: Add release information to job summary
        env:
          GITHUB_TOKEN: ${{ github.token }}
          CUSTOM_RELEASE_NOTES: ${{ inputs.release-notes }}
        run: |
          echo "# Release Check Summary" >> "$GITHUB_STEP_SUMMARY"

          if [[ "${{ steps.bumpr-dry-run.outputs.skip }}" == "true" ]]; then
            {
              echo "## ⚠️ No Release Needed"
              echo "No version bump label was found on the PR. Release will be skipped."
            } >> "$GITHUB_STEP_SUMMARY"
          else
            {
              echo "## ✅ Release Needed"
              echo "A version bump label was found. The following release will be created:"
              echo ""
            } >> "$GITHUB_STEP_SUMMARY"

            # Use action-bumpr outputs with better formatting
            if [[ "${{ steps.bumpr-dry-run.outputs.next_version }}" != "" ]]; then
              CURRENT_VERSION="${{ steps.bumpr-dry-run.outputs.current_version }}"
              NEXT_VERSION="${{ steps.bumpr-dry-run.outputs.next_version }}"
              REPO_URL="https://github.com/${{ github.repository }}"
              COMPARE_URL="$REPO_URL/compare/$CURRENT_VERSION...${{ github.sha }}"

              # Create a more visually appealing format with emojis
              {
                echo "### Release Details"
                echo ""
                echo "🏷️ **New Version:** \`$NEXT_VERSION\`"
                echo ""
                echo "📦 **Current Version:** \`$CURRENT_VERSION\`"
                echo ""
              } >> "$GITHUB_STEP_SUMMARY"

              # Add tag message if available
              if [[ "${{ steps.bumpr-dry-run.outputs.message }}" != "" ]]; then
                {
                  echo "📝 **Tag Message:** ${{ steps.bumpr-dry-run.outputs.message }}"
                  echo ""
                } >> "$GITHUB_STEP_SUMMARY"
              fi

              # Add GitHub compare link
              {
                echo "📊 **Changes:** [View changes since $CURRENT_VERSION]($COMPARE_URL)"
                echo ""
              } >> "$GITHUB_STEP_SUMMARY"

              # Generate and add release notes
              {
                echo "### 📝 Release Notes Preview"
                echo ""
              } >> "$GITHUB_STEP_SUMMARY"

              # Check if custom release notes are provided
              if [[ -n "${CUSTOM_RELEASE_NOTES}" ]]; then
                # Use custom release notes
                {
                  echo "**Note:** Using custom release notes provided as input"
                  echo ""
                  echo "${CUSTOM_RELEASE_NOTES}"
                  echo ""
                } >> "$GITHUB_STEP_SUMMARY"
              else
                # Generate release notes using GitHub API
                REPO="${{ github.repository }}"

                # Call the API with the parameters (CURRENT_VERSION will be empty string if not set)
                RELEASE_NOTES=$(gh api \
                  --method POST \
                  -H "Accept: application/vnd.github+json" \
                  "/repos/${REPO}/releases/generate-notes" \
                  -f target_commitish="${{ github.sha }}" \
                  -f tag_name="$NEXT_VERSION" \
                  -f previous_tag_name="$CURRENT_VERSION" \
                  --jq '.body')

                # Add the generated release notes to the summary
                {
                  echo "$RELEASE_NOTES"
                  echo ""
                } >> "$GITHUB_STEP_SUMMARY"
              fi
            fi
          fi

  # Environment protection job
  # This job intentionally deploys to the environment to satisfy environment
  # protection rules and avoid "Missing successful active release deployment".
  # It also serves as the single approval gate for the release flow.
  release-approval:
    needs: [release-check]
    if: needs.release-check.outputs.skip != 'true'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    concurrency:
      group: "release-approval"
      cancel-in-progress: true
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Approve release
        run: |
          echo "Release approved in the '${{ inputs.environment }}' environment"
          echo "This job exists to satisfy environment deployment requirements."

  # Version management and tag creation job
  version:
    needs: [release-approval]
    runs-on: ubuntu-latest
    permissions:
      id-token: write # Enable OIDC
      contents: write # Tag updates
      pull-requests: write # Post comment
    outputs:
      tag_name: ${{ steps.tag.outputs.value }}
      version: ${{ steps.extract-version.outputs.version }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - uses: actions/checkout@v5
        with:
          ref: ${{ inputs.ref }}

      # Set up signed tag configuration
      - uses: chainguard-dev/actions/setup-gitsign@v1.4.14

      # Bump version based on PR labels (bump:major,bump:minor,bump:patch)
      - id: bumpr
        uses: haya14busa/action-bumpr@v1.11.4

      # Get tag name from bumpr output only
      - id: tag
        run: |
          if [[ "${{ steps.bumpr.outputs.skip }}" == "true" ]]; then
            echo "value=" >> "$GITHUB_OUTPUT"
            echo "No version bump label found, skipping release."
          else
            TAG="${{ steps.bumpr.outputs.next_version }}"
            echo "value=${TAG}" >> "$GITHUB_OUTPUT"
            echo "Next version: ${TAG}"
          fi

      # Extract version number without "v" prefix (v1.2.3 → 1.2.3)
      - id: extract-version
        if: steps.tag.outputs.value != ''
        run: |
          TAG="${{ steps.tag.outputs.value }}"
          VERSION="${TAG#refs/tags/v}"
          VERSION="${VERSION#v}"
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "Extracted version: ${VERSION}"

  goreleaser:
    needs: [release-approval, version]
    if: needs.version.outputs.tag_name != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write # needed to write releases
      id-token: write # needed for keyless signing
      attestations: write # needed for provenance
    outputs:
      artifacts: ${{ steps.goreleaser.outputs.artifacts }}
      checksum_file: ${{ steps.checksumtxt.outputs.checksum_file }}
      hashes: ${{ steps.binstaller-hashes.outputs.combined_hashes || steps.checksumtxt.outputs.hashes }}
      config_exists: ${{ steps.check-config.outputs.config_exists }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - uses: actions/checkout@v5
        with:
          ref: ${{ inputs.ref }}
          fetch-depth: 0 # this is important, otherwise it won't checkout the full tree (i.e. no previous tags)

      # Determine whether to setup Go
      # Logic:
      # - If setup-go is explicitly set (true/false), use that value
      # - Otherwise, setup Go unless Zig is enabled
      - name: Determine Go setup
        id: determine-go-setup
        run: |
          if [[ "${{ inputs.setup-go }}" == "true" ]]; then
            echo "should_setup=true" >> "$GITHUB_OUTPUT"
          elif [[ "${{ inputs.setup-go }}" == "false" ]]; then
            echo "should_setup=false" >> "$GITHUB_OUTPUT"
          elif [[ "${{ inputs.setup-zig }}" == "true" ]]; then
            echo "should_setup=false" >> "$GITHUB_OUTPUT"
          else
            echo "should_setup=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Setup Go
        if: steps.determine-go-setup.outputs.should_setup == 'true'
        uses: actions/setup-go@v6
        with:
          go-version-file: ${{ inputs.go-version-file }}

      - name: Setup Zig
        if: inputs.setup-zig
        uses: mlugg/setup-zig@8d6198c65fb0feaa111df26e6b467fea8345e46f # v2.0.5
        with:
          version: ${{ inputs.zig-version }}

      # Provide dlltool for windows-gnu without hijacking cc/c++
      - name: Install mingw binutils (dlltool)
        if: inputs.install-mingw-dlltool
        run: sudo apt-get update && sudo apt-get install -y binutils-mingw-w64

      - uses: sigstore/cosign-installer@v3.9.2 # installs cosign
      - uses: anchore/sbom-action/download-syft@v0.20.5 # installs syft

      # Create temporary release notes file if custom notes are provided
      - name: Prepare custom release notes
        if: inputs.release-notes != ''
        id: custom-release-notes
        env:
          CUSTOM_RELEASE_NOTES: ${{ inputs.release-notes }}
        run: |
          NOTES_FILE=$(mktemp)
          echo "$CUSTOM_RELEASE_NOTES" > "$NOTES_FILE"
          echo "file=$NOTES_FILE" >> "$GITHUB_OUTPUT"

      - uses: goreleaser/goreleaser-action@v6 # run goreleaser
        id: goreleaser
        with:
          version: '~> v2'
          args: release --clean --draft${{ steps.custom-release-notes.outputs.file && format(' --release-notes {0}', steps.custom-release-notes.outputs.file) || '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Get checksum file name
        id: checksumtxt
        env:
          ARTIFACTS: ${{ steps.goreleaser.outputs.artifacts }}
        run: |
          checksum_file=$(echo "$ARTIFACTS" | jq -r '.[] | select (.type=="Checksum") | .name')
          echo "checksum file: ${checksum_file}"
          echo "checksum_file=${checksum_file}" >> "$GITHUB_OUTPUT"
          echo "hashes=$(cat "dist/$checksum_file" | base64 -w0)" >> "$GITHUB_OUTPUT"
      - uses: actions/attest-build-provenance@v3
        with:
          subject-checksums: ./dist/${{ steps.checksumtxt.outputs.checksum_file }}
      # Generate attestations for checksum file itself.
      - uses: actions/attest-build-provenance@v3
        with:
          subject-path: ./dist/${{ steps.checksumtxt.outputs.checksum_file }}

      # Binstaller steps
      - name: Check for binstaller config
        id: check-config
        run: |
          if [[ -f .config/binstaller.yml || -f .config/binstaller.yaml ]]; then
            echo "config_exists=true" >> "$GITHUB_OUTPUT"
            echo "Binstaller config found"
          else
            echo "config_exists=false" >> "$GITHUB_OUTPUT"
            echo "No binstaller config found, skipping binstaller steps"
          fi
      - uses: actionutils/trusted-tag-verifier@v0
        if: steps.check-config.outputs.config_exists == 'true'
        with:
          verify: 'binary-install/setup-x@v1'
      - name: Install binstaller
        if: steps.check-config.outputs.config_exists == 'true'
        uses: binary-install/setup-x@v1
        with:
          script_url: https://raw.githubusercontent.com/binary-install/binstaller/main/install.sh
          gh_attestations_verify_flags: --repo binary-install/binstaller --cert-identity-regex=.github/workflows/generate-installer.yml@refs/heads/main
      - name: Embed checksums
        if: steps.check-config.outputs.config_exists == 'true'
        env:
          checksum_file: ${{ steps.checksumtxt.outputs.checksum_file }}
        run: binst embed-checksums --mode=checksum-file --file="./dist/${checksum_file}" --version='${{ needs.version.outputs.tag_name }}'
      - name: Generate installer and runner scripts
        if: steps.check-config.outputs.config_exists == 'true'
        run: |
          binst gen --type=installer --target-version='${{ needs.version.outputs.tag_name }}' --output=./dist/install.sh
          binst gen --type=runner --target-version='${{ needs.version.outputs.tag_name }}' --output=./dist/run.sh
      - name: Sign installer and runner with cosign
        if: steps.check-config.outputs.config_exists == 'true'
        run: |
          cosign sign-blob \
            --yes \
            --output-signature ./dist/install.sh.sig \
            --output-certificate ./dist/install.sh.pem \
            ./dist/install.sh
          cosign sign-blob \
            --yes \
            --output-signature ./dist/run.sh.sig \
            --output-certificate ./dist/run.sh.pem \
            ./dist/run.sh
      - name: Upload installer and runner to release
        if: steps.check-config.outputs.config_exists == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release upload '${{ needs.version.outputs.tag_name }}' \
            ./dist/install.sh \
            ./dist/install.sh.sig \
            ./dist/install.sh.pem \
            ./dist/run.sh \
            ./dist/run.sh.sig \
            ./dist/run.sh.pem
      - name: Calculate binstaller scripts hashes
        if: steps.check-config.outputs.config_exists == 'true'
        id: binstaller-hashes
        run: |
          cd dist
          # Combine goreleaser checksums with installer/runner scripts hashes in one command
          checksum_file="${{ steps.checksumtxt.outputs.checksum_file }}"
          combined_hashes=$(cat "$checksum_file" <(sha256sum install.sh run.sh) | base64 -w0)

          echo "combined_hashes=${combined_hashes}" >> "$GITHUB_OUTPUT"
          echo "Binstaller scripts hashes calculated and combined"
      - name: Attest binstaller scripts
        if: steps.check-config.outputs.config_exists == 'true'
        uses: actions/attest-build-provenance@v3
        with:
          subject-path: |
            ./dist/install.sh
            ./dist/run.sh

  provenance:
    if: needs.version.outputs.tag_name != ''
    needs: [release-approval, version, goreleaser]
    permissions:
      actions: read # To read the workflow path.
      id-token: write # To sign the provenance.
      contents: write # To add assets to a release.
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@v2.1.0
    with:
      base64-subjects: "${{ needs.goreleaser.outputs.hashes }}"
      upload-assets: true # upload to a new release
      upload-tag-name: "${{ needs.version.outputs.tag_name }}"
      draft-release: true # use existing draft release created by goreleaser

  release:
    needs: [release-approval, version, goreleaser, provenance]
    if: needs.version.outputs.tag_name != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required for release creation
    outputs:
      release_url: ${{ steps.update_release.outputs.release_url }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
          ref: ${{ needs.version.outputs.tag_name }}

      - name: Create base verification instructions
        id: create_base_instructions
        run: |
          TEMP_FILE=$(mktemp)
          cat > "$TEMP_FILE" << 'EOF'

          <details>
          <summary>📋 Release Verification Instructions</summary>

          ## Verifying Release Artifacts

          ### Using Cosign

          All release artifacts are signed using [Sigstore](https://sigstore.dev/) and can be verified using [cosign](https://github.com/sigstore/cosign):

          ```bash
          # Download the release assets
          gh release download ${{ needs.version.outputs.tag_name }} --repo ${{ github.repository }}

          # Verify the checksum file signature
          cosign verify-blob \
            --certificate-identity-regexp '^https://github.com/actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml@.*$' \
            --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \
            --cert "${{ needs.goreleaser.outputs.checksum_file }}.pem" \
            --signature "${{ needs.goreleaser.outputs.checksum_file }}.sig" \
            "${{ needs.goreleaser.outputs.checksum_file }}"

          # Verify checksums of all binaries
          sha256sum --ignore-missing -c "${{ needs.goreleaser.outputs.checksum_file }}"
          ```

          ### Using GitHub Attestations

          All artifacts have [GitHub Attestations](https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds) that can be verified:

          ```bash
          # Verify attestations for the checksum file
          gh attestation verify "${{ needs.goreleaser.outputs.checksum_file }}" --repo ${{ github.repository }} --signer-workflow='actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml'
          ```

          EOF
          echo "base_instructions_file=$TEMP_FILE" >> "$GITHUB_OUTPUT"

      - name: Add binstaller instructions
        id: add_binstaller_instructions
        run: |
          BASE_FILE="${{ steps.create_base_instructions.outputs.base_instructions_file }}"
          echo "Binstaller config exists: ${{ needs.goreleaser.outputs.config_exists }}"

          # Close the verification instructions details
          cat >> "$BASE_FILE" << 'CLOSE_VERIFICATION_EOF'

          </details>
          CLOSE_VERIFICATION_EOF

          if [[ "${{ needs.goreleaser.outputs.config_exists }}" == "true" ]]; then
            echo "Adding binstaller instructions..."
            cat >> "$BASE_FILE" << 'BINSTALLER_EOF'

          <details>
          <summary>📦 Installation Scripts</summary>

          This release includes installation scripts generated by [binstaller](https://github.com/binary-install/binstaller):

          - `install.sh` - Downloads and installs the binary
          - `run.sh` - Downloads and runs the binary directly

          ## Verifying Installation Scripts

          Before using the installation scripts, you can verify their authenticity using cosign (signatures) or GitHub Attestations.

          ```bash
          # Download the scripts and their signatures
          gh release download ${{ needs.version.outputs.tag_name }} --pattern "*.sh*" --repo ${{ github.repository }}

          # Verify with cosign (recommended)
          cosign verify-blob \
            --certificate-identity-regexp '^https://github.com/actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml@.*$' \
            --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \
            --cert install.sh.pem \
            --signature install.sh.sig \
            install.sh

          cosign verify-blob \
            --certificate-identity-regexp '^https://github.com/actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml@.*$' \
            --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \
            --cert run.sh.pem \
            --signature run.sh.sig \
            run.sh

          # Or verify with GitHub Attestations
          # Verify the install script
          gh attestation verify install.sh --repo ${{ github.repository }} --signer-workflow='actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml'

          # Verify the run script
          gh attestation verify run.sh --repo ${{ github.repository }} --signer-workflow='actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml'
          ```

          ## Using Installation Scripts

          ```bash
          # Install the binary
          curl -sSfL https://github.com/${{ github.repository }}/releases/download/${{ needs.version.outputs.tag_name }}/install.sh | sh

          # Or run directly without installation
          curl -sSfL https://github.com/${{ github.repository }}/releases/download/${{ needs.version.outputs.tag_name }}/run.sh | sh
          ```

          ## One-liner Installation with Verification

          ### Using Cosign (recommended)

          ```bash
          # Set the desired version and script type
          VERSION="${{ needs.version.outputs.tag_name }}"
          SCRIPT="install.sh"  # or "run.sh"
          DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/${VERSION}"

          # Download and verify with cosign, then execute
          curl -sL "${DOWNLOAD_URL}/${SCRIPT}" | \
              (tmpfile=$(mktemp); cat > "$tmpfile"; \
               cosign verify-blob \
                 --certificate-identity-regexp '^https://github.com/actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml@.*$' \
                 --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \
                 --certificate "${DOWNLOAD_URL}/${SCRIPT}.pem" \
                 --signature "${DOWNLOAD_URL}/${SCRIPT}.sig" \
                 "$tmpfile" && \
               sh "$tmpfile"; rm -f "$tmpfile")
          ```

          ### Using GitHub Attestations

          ```bash
          # Set the desired version
          VERSION="${{ needs.version.outputs.tag_name }}"

          # Install with attestation verification
          curl -sL "https://github.com/${{ github.repository }}/releases/download/${VERSION}/install.sh" | \
              (tmpfile=$(mktemp); cat > "$tmpfile"; \
               gh attestation verify --repo=${{ github.repository }} --signer-workflow='actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml' "$tmpfile" && \
               sh "$tmpfile"; rm -f "$tmpfile")
          ```

          </details>
          BINSTALLER_EOF
          else
            echo "No binstaller config found, skipping binstaller instructions"
          fi

          echo "instructions_file=$BASE_FILE" >> "$GITHUB_OUTPUT"


      - name: Update GitHub Release
        id: update_release
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
          CUSTOM_RELEASE_NOTES: ${{ inputs.release-notes }}
        run: |
          TAG_NAME="${{ needs.version.outputs.tag_name }}"

          # Determine release body content
          if [[ -n "${CUSTOM_RELEASE_NOTES}" ]]; then
            # Use custom release notes if provided
            RELEASE_BODY="${CUSTOM_RELEASE_NOTES}"
          else
            # Get current release body (auto-generated by goreleaser)
            RELEASE_BODY=$(gh release view "$TAG_NAME" --json body --jq '.body')
          fi

          # Get final verification instructions
          VERIFICATION_INSTRUCTIONS=$(cat "${{ steps.add_binstaller_instructions.outputs.instructions_file }}")

          # Combine release body with verification instructions
          NEW_BODY="${RELEASE_BODY}${VERIFICATION_INSTRUCTIONS}"

          # Update release with combined body
          RELEASE_URL=$(gh release edit "$TAG_NAME" \
            --title "Release $TAG_NAME" \
            --notes "$NEW_BODY" \
            --draft=${{ inputs.draft }})

          echo "release_url=$RELEASE_URL" >> "$GITHUB_OUTPUT"
          echo "Release URL: $RELEASE_URL"

  # https://goreleaser.com/install/#verifying-the-artifacts
  verification-with-cosign:
    needs: [release-approval, version, release, goreleaser]
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.9.2

      - name: Download assets
        env:
          GH_TOKEN: ${{ github.token }}
          TAG_NAME: ${{ needs.version.outputs.tag_name }}
        run: |
          gh -R "${GITHUB_REPOSITORY}" release download "${TAG_NAME}"

      - name: Verify checksum signature
        env:
          checksum_file: ${{ needs.goreleaser.outputs.checksum_file }}
        run: |
          cosign verify-blob \
            --certificate-identity-regexp '^https://github.com/actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml@.*$' \
            --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \
            --cert "${checksum_file}.pem" \
            --signature "${checksum_file}.sig" \
            "${checksum_file}"

      - name: Verify checksum
        env:
          checksum_file: ${{ needs.goreleaser.outputs.checksum_file }}
        run: |
          sha256sum --ignore-missing -c "${checksum_file}"
      - name: Verify installer/runner signatures
        run: |
          if [[ -f install.sh && -f install.sh.sig && -f install.sh.pem ]]; then
            cosign verify-blob \
              --certificate-identity-regexp '^https://github.com/actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml@.*$' \
              --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \
              --cert install.sh.pem \
              --signature install.sh.sig \
              install.sh
          fi
          if [[ -f run.sh && -f run.sh.sig && -f run.sh.pem ]]; then
            cosign verify-blob \
              --certificate-identity-regexp '^https://github.com/actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml@.*$' \
              --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \
              --cert run.sh.pem \
              --signature run.sh.sig \
              run.sh
          fi
